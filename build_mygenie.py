#!/usr/bin/env python3
"""
Cross-platform packaging script for ChatAI Agent
Supports macOS and Windows with proper config file handling
"""

import os
import sys
import shutil
import subprocess
import platform
import json
import multiprocessing
import time
from pathlib import Path
from typing import Dict, Any
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor, as_completed

# External config files (contain personal API keys)
EXTERNAL_CONFIG_FILES = [
    "config.json",
    "mcp.json",
    "news_config.json",
    "prompt_config.json",
]

# Internal config files (no personal data)
INTERNAL_CONFIG_FILES = [
    "ai_model.json",
    "templates.json",
    "theme.json",
    "mcp_server_state.json",
    "splitter_state.json",
    "user_config_path.json",
]


class PackageBuilder:
    def __init__(self):
        self.system = platform.system()
        self.project_root = Path.cwd()
        self.backup_dir = self.project_root / "backup_configs"

    def backup_configs(self):
        """Backup existing config files"""
        self.backup_dir.mkdir(exist_ok=True)

        for file in EXTERNAL_CONFIG_FILES:
            if (self.project_root / file).exists():
                shutil.copy(self.project_root / file, self.backup_dir / file)
                print(f"‚úì Backed up {file}")

    def restore_configs(self):
        """Restore backed up config files"""
        if not self.backup_dir.exists():
            print("‚ö†Ô∏è Î∞±ÏóÖ ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§.")
            return

        restored_count = 0
        for file in EXTERNAL_CONFIG_FILES:
            backup_file = self.backup_dir / file
            target_file = self.project_root / file

            if backup_file.exists():
                try:
                    shutil.copy(backup_file, target_file)
                    print(f"‚úì Restored {file}")
                    restored_count += 1
                except Exception as e:
                    print(f"‚ùå Failed to restore {file}: {e}")
            else:
                print(f"‚ö†Ô∏è No backup found for {file}")

        # Î∞±ÏóÖ ÎîîÎ†âÌÜ†Î¶¨ Ï†ïÎ¶¨
        try:
            shutil.rmtree(self.backup_dir)
            print(f"‚úì Cleanup backup directory ({restored_count} files restored)")
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to cleanup backup directory: {e}")

    def create_sample_configs(self):
        """Create sample config files for packaging"""

        # Sample config.json (no personal keys)
        config_sample = {
            "current_model": "gemini-2.0-flash",
            "models": {
                "gemini-2.0-flash": {
                    "api_key": "YOUR_GOOGLE_API_KEY",
                    "provider": "google",
                },
                "gpt-3.5-turbo": {
                    "api_key": "YOUR_OPENAI_API_KEY",
                    "provider": "openai",
                },
                "sonar-pro": {
                    "api_key": "YOUR_PERPLEXITY_API_KEY",
                    "provider": "perplexity",
                },
                "pollinations-mistral": {
                    "provider": "pollinations",
                    "api_key": "free",
                    "description": "Free coding model",
                    "model_id": "mistral",
                },
            },
            "conversation_settings": {
                "enable_history": True,
                "max_history_pairs": 5,
                "max_tokens_estimate": 20000,
            },
            "response_settings": {
                "max_tokens": 4096,
                "enable_streaming": True,
                "streaming_chunk_size": 100,
            },
            "current_theme": "material_dark",
        }

        # Sample mcp.json (no personal keys/tokens)
        mcp_sample = {
            "mcpServers": {
                "filesystem": {
                    "command": "npx",
                    "args": [
                        "-y",
                        "@modelcontextprotocol/server-filesystem",
                        "/path/to/your/directory",
                    ],
                    "description": "File system access - Change path to your directory",
                },
                "search-server": {
                    "command": "node",
                    "args": ["/path/to/search-server.js"],
                    "env": {"PERPLEXITY_API_KEY": "YOUR_PERPLEXITY_API_KEY"},
                    "description": "Search server - Add your Perplexity API key",
                },
                "mysql": {
                    "command": "npx",
                    "args": ["mysql-mcp-server"],
                    "env": {
                        "MYSQL_HOST": "localhost",
                        "MYSQL_PORT": "3306",
                        "MYSQL_USER": "YOUR_MYSQL_USER",
                        "MYSQL_PASSWORD": "YOUR_MYSQL_PASSWORD",
                        "MYSQL_DATABASE": "YOUR_DATABASE_NAME",
                    },
                    "description": "MySQL database access - Configure your database credentials",
                },
                "gmail": {
                    "command": "npx",
                    "args": ["@gongrzhe/server-gmail-autoauth-mcp"],
                    "description": "Gmail access - Requires OAuth setup",
                },
                "notion": {
                    "command": "npx",
                    "args": ["-y", "@notionhq/notion-mcp-server"],
                    "env": {
                        "OPENAPI_MCP_HEADERS": '{"Authorization": "Bearer YOUR_NOTION_TOKEN", "Notion-Version": "2025-06-29"}'
                    },
                    "description": "Notion API access - Add your Notion integration token",
                },
            }
        }

        # Sample news_config.json
        news_sample = {
            "news_sources": {"domestic": [], "international": [], "earthquake": []},
            "update_interval": 300,
            "max_articles": 10,
        }

        # Sample prompt_config.json
        prompt_sample = {
            "conversation_settings": {
                "enable_history": True,
                "hybrid_mode": True,
                "user_message_limit": 4,
                "ai_response_limit": 4,
                "ai_response_token_limit": 5000,
                "max_history_pairs": 4,
                "max_tokens_estimate": 10000,
            },
            "response_settings": {
                "enable_length_limit": False,
                "max_tokens": 4096,
                "max_response_length": 50000,
                "enable_streaming": True,
                "streaming_chunk_size": 300,
            },
            "language_detection": {
                "korean_threshold": 0.1,
                "description": "Korean character ratio threshold for language detection (0.0-1.0)",
            },
            "theme": {"current_theme": "material_high_contrast"},
            "history_settings": {"initial_load_count": 20, "page_size": 10},
        }

        # Write sample files
        samples = {
            "config.json": config_sample,
            "mcp.json": mcp_sample,
            "news_config.json": news_sample,
            "prompt_config.json": prompt_sample,
        }

        # Reset user config path for packaging
        user_config_reset = {}
        with open(
            self.project_root / "user_config_path.json", "w", encoding="utf-8"
        ) as f:
            json.dump(user_config_reset, f, indent=2, ensure_ascii=False)

        for filename, content in samples.items():
            with open(self.project_root / filename, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2, ensure_ascii=False)
            print(f"‚úì Created sample {filename} (Í∞úÏù∏ÌÇ§ Ï†úÍ±∞Îê®)")

        print("‚úì Reset user_config_path.json (Ïô∏Î∂Ä Í≤ΩÎ°ú Ï¥àÍ∏∞Ìôî)")

    def clean_build(self):
        """ÎπåÎìú ÎîîÎ†âÌÜ†Î¶¨ Î∞è Ï∫êÏãú Ï†ïÎ¶¨ (ÌÅ¨Î°úÏä§ ÌîåÎû´Ìèº Ìò∏Ìôò)"""
        print("üßπ ÎπåÎìú ÌôòÍ≤Ω Ï†ïÎ¶¨ Ï§ë...")

        # 1. Í∏∞Ï°¥ ÎπåÎìú ÎîîÎ†âÌÜ†Î¶¨ ÏÇ≠Ï†ú
        dirs_to_clean = ["build" if self.system != "Windows" else "build_windows", "dist", "dist_windows"]
        for dir_name in dirs_to_clean:
            dir_path = self.project_root / dir_name
            if dir_path.exists():
                try:
                    shutil.rmtree(dir_path)
                    print(f"‚úì Cleaned {dir_name}")
                except Exception as e:
                    print(f"‚ö† {dir_name} ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò: {e}")

        # 2. __pycache__ Ïû¨Í∑ÄÏ†Å ÏÇ≠Ï†ú (PythonÏúºÎ°ú Ï≤òÎ¶¨)
        try:
            for pycache in self.project_root.rglob("__pycache__"):
                if pycache.is_dir():
                    shutil.rmtree(pycache)
            print("‚úì Cleaned __pycache__")
        except Exception as e:
            print(f"‚ö† __pycache__ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

        # 3. PyInstaller Ï∫êÏãú Ï†ïÎ¶¨
        pyinstaller_cache = Path.home() / ".pyinstaller_cache"
        if pyinstaller_cache.exists():
            try:
                shutil.rmtree(pyinstaller_cache)
                print("‚úì Cleaned PyInstaller cache")
            except Exception as e:
                print(f"‚ö† PyInstaller Ï∫êÏãú Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

        print("‚úÖ ÎπåÎìú ÌôòÍ≤Ω Ï†ïÎ¶¨ ÏôÑÎ£å")


    def verify_and_fix_dependencies(self):
        """ÎπåÎìú Ï†Ñ ÌïÑÏàò ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Î∞è ÏûêÎèô ÏàòÏ†ï"""
        print("üîç ÌïÑÏàò ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Î∞è ÏûêÎèô ÏàòÏ†ï Ï§ë...")
        
        required_packages = [
            # Core dependencies with hooks
            ('cryptography', '42.0.8'),
            ('Crypto', None),  # pycryptodome
            ('keyring', None),
            ('loguru', None),
            # UI and framework
            ('PyQt6', None),
            # AI/ML libraries
            ('langchain', None),
            ('openai', None),
            # Data science libraries (with hooks)
            ('pandas', None),
            ('numpy', None),
            ('matplotlib', None),
            ('seaborn', None),
            ('scipy', None),
        ]
        
        needs_reinstall = []
        for package_info in required_packages:
            package = package_info[0]
            version = package_info[1]
            
            try:
                __import__(package)
                print(f"‚úì {package}")
            except ImportError:
                needs_reinstall.append(package_info)
                print(f"‚ùå {package} ÎàÑÎùΩ")
        
        if needs_reinstall:
            print(f"\nüîß ÎàÑÎùΩÎêú Ìå®ÌÇ§ÏßÄ ÏûêÎèô ÏÑ§Ïπò Ï§ë...")
            for package, version in needs_reinstall:
                try:
                    if version:
                        cmd = ['pip', 'install', '--force-reinstall', '--no-cache-dir', f'{package}=={version}']
                    else:
                        cmd = ['pip', 'install', package]
                    
                    print(f"  ÏÑ§Ïπò Ï§ë: {package}...")
                    result = subprocess.run(cmd, check=True, capture_output=True, text=True)
                    print(f"  ‚úì {package} ÏÑ§Ïπò ÏôÑÎ£å")
                except subprocess.CalledProcessError as e:
                    print(f"  ‚ùå {package} ÏÑ§Ïπò Ïã§Ìå®: {e}")
                    return False
        
        # cryptographyÎäî Ìï≠ÏÉÅ Í∞ïÏ†ú Ïû¨ÏÑ§Ïπò (ÎπåÎìú Î¨∏Ï†ú Î∞©ÏßÄ)
        print("\nüîê cryptography Î™®Îìà Í∞ïÏ†ú Ïû¨ÏÑ§Ïπò (ÎπåÎìú ÏïàÏ†ïÏÑ± ÌôïÎ≥¥)...")
        try:
            cmd = ['pip', 'install', '--force-reinstall', '--no-cache-dir', 'cryptography==42.0.8']
            subprocess.run(cmd, check=True, capture_output=True, text=True)
            print("‚úì cryptography Ïû¨ÏÑ§Ïπò ÏôÑÎ£å")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå cryptography Ïû¨ÏÑ§Ïπò Ïã§Ìå®: {e}")
            return False
        
        print("‚úÖ Î™®Îì† ÌïÑÏàò ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Î∞è ÏàòÏ†ï ÏôÑÎ£å")
        return True

    def build_executable(self, parallel_jobs=None):
        """Build executable using PyInstaller with parallel processing"""
        # ÎπåÎìú Ï†Ñ ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Î∞è ÏûêÎèô ÏàòÏ†ï
        if not self.verify_and_fix_dependencies():
            print("‚ùå ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Î∞è ÏàòÏ†ï Ïã§Ìå®. ÎπåÎìúÎ•º Ï§ëÎã®Ìï©ÎãàÎã§.")
            return False
        
        if parallel_jobs is None:
            cpu_cores = multiprocessing.cpu_count()
            parallel_jobs = min(cpu_cores, 8)
            print(f"üíª CPU ÏΩîÏñ¥: {cpu_cores}Í∞ú, Î≥ëÎ†¨ ÏûëÏóÖ: {parallel_jobs}Í∞ú")

        # ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Î≥ëÎ†¨ Ï≤òÎ¶¨ ÏÑ§Ï†ï
        import os

        os.environ["PYINSTALLER_COMPILE_BOOTLOADER_PARALLEL"] = str(parallel_jobs)
        
        # WindowsÏóêÏÑúÎäî dist_windows, build_windows ÏÇ¨Ïö©
        dist_path = "dist_windows" if self.system == "Windows" else "dist"
        build_path = "build_windows" if self.system == "Windows" else "build"
        
        try:
            cmd = [
                "pyinstaller",
                "--noconfirm",
                "--clean",
                "--log-level=INFO",
                f"--distpath={dist_path}",
                f"--workpath={build_path}",
                "my_genie.spec",
            ]
            print(f"üöÄ Î≥ëÎ†¨ ÎπåÎìú ÏãúÏûë: {' '.join(cmd)}")

            start_time = time.time()
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            end_time = time.time()

            if result.stdout:
                print("Build output:")
                print(result.stdout)

            print(
                f"‚úÖ PyInstaller build completed in {end_time - start_time:.2f} seconds"
            )
            return True

        except subprocess.CalledProcessError as e:
            print(f"‚ùå Build failed: {e}")
            if e.stdout:
                print(f"stdout: {e.stdout}")
            if e.stderr:
                print(f"stderr: {e.stderr}")
            return False
        except FileNotFoundError:
            print("‚ùå PyInstaller not found. Install with: pip install pyinstaller")
            return False

    def create_distribution_package(self):
        """Create distribution packages"""
        dist_dir = self.project_root / ("dist_windows" if self.system == "Windows" else "dist")

        if self.system == "Darwin":  # macOS
            app_path = dist_dir / "MyGenie.app"
            if app_path.exists():
                print(f"‚úì macOS app created: {app_path}")

                # Create DMG with drag-and-drop UI
                try:
                    self._create_dmg_with_ui(app_path, dist_dir)
                except Exception as e:
                    print(f"‚ö† DMG creation failed: {e}")

        elif self.system == "Windows":
            exe_path = dist_dir / "MyGenie_beta.exe"
            if exe_path.exists():
                print(f"‚úì Windows executable created: {exe_path}")

                # Create ZIP
                try:
                    import zipfile

                    zip_path = dist_dir / "MyGenie_beta-Windows.zip"
                    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zipf:
                        zipf.write(exe_path, exe_path.name)
                    print(f"‚úì ZIP package created: {zip_path}")
                except Exception as e:
                    print(f"‚ö† ZIP creation failed: {e}")

        else:  # Linux
            exe_path = dist_dir / "MyGenie"
            if exe_path.exists():
                print(f"‚úì Linux executable created: {exe_path}")

                # Create TAR.GZ
                try:
                    import tarfile

                    tar_path = dist_dir / "MyGenie-Linux.tar.gz"
                    with tarfile.open(tar_path, "w:gz") as tar:
                        tar.add(exe_path, exe_path.name)
                    print(f"‚úì TAR.GZ package created: {tar_path}")
                except Exception as e:
                    print(f"‚ö† TAR.GZ creation failed: {e}")

    def verify_build(self):
        """Verify build contents"""
        dist_dir = self.project_root / ("dist_windows" if self.system == "Windows" else "dist")

        if self.system == "Darwin":
            app_path = dist_dir / "MyGenie.app"
            resources_path = app_path / "Contents" / "Resources"

            if resources_path.exists():
                print("\nüìã Verifying app bundle contents:")
                required_files = [
                    "theme.json",
                    "templates.json",
                    "ai_model.json",
                    "config.json",
                ]

                for required_file in required_files:
                    file_path = resources_path / required_file
                    if file_path.exists():
                        print(f"‚úì {required_file}")
                    else:
                        print(f"‚ùå {required_file} missing")
                        return False

                print("‚úÖ All required files included")
            
            # cryptography Î™®Îìà ÌôïÏù∏
            print("\nüîê Verifying cryptography module:")
            internal_path = dist_dir / "MyGenie" / "_internal"
            if internal_path.exists():
                crypto_found = False
                crypto_dirs = []
                
                # cryptography ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÍ∏∞
                for item in internal_path.iterdir():
                    if item.is_dir() and 'cryptography' in item.name.lower():
                        crypto_dirs.append(item.name)
                        crypto_found = True
                
                # cryptography Í¥ÄÎ†® ÌååÏùº Ï∞æÍ∏∞
                for item in internal_path.rglob('*cryptography*'):
                    if item.is_file() and item.suffix in ['.so', '.dylib', '.pyd']:
                        print(f"‚úì Found: {item.relative_to(internal_path)}")
                        crypto_found = True
                
                if crypto_dirs:
                    print(f"‚úì cryptography ÎîîÎ†âÌÜ†Î¶¨: {', '.join(crypto_dirs)}")
                
                if not crypto_found:
                    print("‚ùå cryptography Î™®ÎìàÏù¥ ÎπåÎìúÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§!")
                    print("\nÏûêÎèô ÏàòÏ†ïÏùÑ ÏãúÎèÑÌï©ÎãàÎã§...")
                    print("Îã§Ïùå Î™ÖÎ†πÏùÑ Ïã§ÌñâÌïòÏÑ∏Ïöî:")
                    print("  python build_package.py")
                    return False
                else:
                    print("‚úÖ cryptography Î™®Îìà Ìè¨Ìï® ÌôïÏù∏")
            
            return True

        return True

    def _create_dmg_with_ui(self, app_path: Path, dist_dir: Path):
        """ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ UIÍ∞Ä ÏûàÎäî DMG ÏÉùÏÑ± (macOS Ï†ÑÏö©)"""
        if self.system != "Darwin":
            print("‚ö† DMG creation is only available on macOS")
            return
            
        dmg_name = "MyGenie-macOS"
        temp_dmg = dist_dir / f"{dmg_name}-temp.dmg"
        final_dmg = dist_dir / f"{dmg_name}.dmg"
        temp_dir = self.project_root / "temp_dmg"
        
        # Ï†ïÎ¶¨
        for f in [temp_dmg, final_dmg]:
            if f.exists():
                f.unlink()
        if temp_dir.exists():
            shutil.rmtree(temp_dir)
        
        # Ïï± Î≤àÎì§ Ïã§Ï†ú ÎîîÏä§ÌÅ¨ ÏÇ¨Ïö©Îüâ ÌôïÏù∏ (PythonÏúºÎ°ú Í≥ÑÏÇ∞)
        total_size = sum(f.stat().st_size for f in app_path.rglob('*') if f.is_file())
        size_mb = total_size / (1024 * 1024)
        print(f"üì¶ Ïï± Î≤àÎì§ Ïã§Ï†ú ÌÅ¨Í∏∞: {size_mb:.1f}MB")
        print(f"   (ÏÑ§Ïπò Ïãú Ïù¥ ÌÅ¨Í∏∞ÎßåÌÅº ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ ÏÇ¨Ïö©)")
        
        # ÏûÑÏãú ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ± (Ïã¨Î≥ºÎ¶≠ ÎßÅÌÅ¨ Ïú†ÏßÄ)
        temp_dir.mkdir(exist_ok=True)
        shutil.copytree(app_path, temp_dir / app_path.name, symlinks=True)
        (temp_dir / "Applications").symlink_to("/Applications")
        print("‚úì Applications Ïã¨Î≥ºÎ¶≠ ÎßÅÌÅ¨ ÏÉùÏÑ± (Ïï± ÎÇ¥Î∂Ä Ïã¨Î≥ºÎ¶≠ ÎßÅÌÅ¨ Ïú†ÏßÄ)")
        
        # ÏûÑÏãú DMG ÏÉùÏÑ±
        subprocess.run([
            "hdiutil", "create", "-volname", "MyGenie",
            "-srcfolder", str(temp_dir), "-ov", "-format", "UDRW",
            str(temp_dmg)
        ], check=True)
        
        # DMG ÎßàÏö¥Ìä∏
        mount_result = subprocess.run([
            "hdiutil", "attach", "-readwrite", "-noverify", "-noautoopen",
            str(temp_dmg)
        ], capture_output=True, text=True, check=True)
        
        mount_point = None
        for line in mount_result.stdout.split('\n'):
            if '/Volumes/' in line:
                mount_point = line.split('/Volumes/')[-1].strip()
                mount_point = f"/Volumes/{mount_point}"
                break
        
        if not mount_point:
            raise Exception("DMG ÎßàÏö¥Ìä∏ Ïã§Ìå®")
        
        print(f"‚úì DMG ÎßàÏö¥Ìä∏: {mount_point}")
        
        # Finder ÏÑ§Ï†ï Ï†ÅÏö©
        applescript = f'''
tell application "Finder"
    tell disk "MyGenie"
        open
        set current view of container window to icon view
        set toolbar visible of container window to false
        set statusbar visible of container window to false
        set the bounds of container window to {{100, 100, 700, 500}}
        set viewOptions to the icon view options of container window
        set arrangement of viewOptions to not arranged
        set icon size of viewOptions to 128
        set position of item "MyGenie.app" of container window to {{150, 200}}
        set position of item "Applications" of container window to {{450, 200}}
        close
        open
        update without registering applications
        delay 2
    end tell
end tell
'''
        
        try:
            subprocess.run(["osascript", "-e", applescript], check=True)
            print("‚úì Finder ÏÑ§Ï†ï Ï†ÅÏö© (ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ UI)")
        except Exception as e:
            print(f"‚ö† Finder ÏÑ§Ï†ï Ï†ÅÏö© Ïã§Ìå®: {e}")
        
        # ÎèôÍ∏∞Ìôî Î∞è Ïñ∏ÎßàÏö¥Ìä∏
        subprocess.run(["sync"], check=True)
        subprocess.run(["hdiutil", "detach", mount_point], check=True)
        print("‚úì DMG Ïñ∏ÎßàÏö¥Ìä∏")
        
        # ÏïïÏ∂ï DMG Î≥ÄÌôò (ULFO Ìè¨Îß∑ÏúºÎ°ú ÏµúÎåÄ ÏïïÏ∂ï)
        print("üóúÔ∏è DMG ÏïïÏ∂ï Ï§ë... (ÏãúÍ∞ÑÏù¥ Í±∏Î¶¥ Ïàò ÏûàÏäµÎãàÎã§)")
        subprocess.run([
            "hdiutil", "convert", str(temp_dmg),
            "-format", "ULFO",
            "-o", str(final_dmg)
        ], check=True)
        
        # Ï†ïÎ¶¨
        temp_dmg.unlink()
        shutil.rmtree(temp_dir)
        
        dmg_size = final_dmg.stat().st_size / (1024 * 1024)
        print(f"‚úì DMG ÏÉùÏÑ± ÏôÑÎ£å: {final_dmg.name} ({dmg_size:.1f}MB)")
        print(f"  üìù Îã§Ïö¥Î°úÎìú ÌÅ¨Í∏∞: {dmg_size:.1f}MB")
        print(f"  üíæ ÏÑ§Ïπò ÌõÑ ÌÅ¨Í∏∞: {size_mb:.1f}MB (Ïã¨Î≥ºÎ¶≠ ÎßÅÌÅ¨ Ïú†ÏßÄ)")
        print("  üìå ÏÇ¨Ïö©ÏûêÎäî DMGÎ•º Ïó¥Í≥† Ïï±ÏùÑ Applications Ìè¥ÎçîÎ°ú ÎìúÎûòÍ∑∏ÌïòÏó¨ ÏÑ§Ïπò")
        print("  ‚ö†Ô∏è  Í∏∞Ï°¥ ÏÑ§ÏπòÎêú Ïï±Ïù¥ ÏûàÎã§Î©¥ ÏÇ≠Ï†ú ÌõÑ Ïû¨ÏÑ§Ïπò Í∂åÏû•")

    def test_executable(self):
        """ÎπåÎìúÎêú Ïã§Ìñâ ÌååÏùº ÌÖåÏä§Ìä∏"""
        dist_dir = self.project_root / ("dist_windows" if self.system == "Windows" else "dist")
        
        if self.system == "Darwin":
            exe_path = dist_dir / "MyGenie" / "MyGenie"
        elif self.system == "Windows":
            exe_path = dist_dir / "MyGenie_beta.exe"
        else:
            exe_path = dist_dir / "MyGenie"
        
        if not exe_path.exists():
            print(f"‚ùå Ïã§Ìñâ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {exe_path}")
            return False
        
        print(f"Ïã§Ìñâ ÌååÏùº ÌÖåÏä§Ìä∏: {exe_path}")
        try:
            # 5Ï¥à ÌÉÄÏûÑÏïÑÏõÉÏúºÎ°ú Ïã§Ìñâ ÌÖåÏä§Ìä∏
            result = subprocess.run(
                [str(exe_path)],
                capture_output=True,
                text=True,
                timeout=5
            )
        except subprocess.TimeoutExpired:
            # GUI Ïï±Ïù¥ÎØÄÎ°ú ÌÉÄÏûÑÏïÑÏõÉÏùÄ Ï†ïÏÉÅ (Ïã§ÌñâÏùÄ ÏÑ±Í≥µ)
            print("‚úì Ïã§Ìñâ ÌååÏùºÏù¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏãúÏûëÎê® (GUI Ïï±)")
            return True
        except Exception as e:
            print(f"‚ùå Ïã§Ìñâ ÌÖåÏä§Ìä∏ Ïã§Ìå®: {e}")
            if result.stderr:
                print(f"ÏóêÎü¨ Ï∂úÎ†•:\n{result.stderr[:500]}")
            return False
        
        # Ï¶âÏãú Ï¢ÖÎ£åÎêú Í≤ΩÏö∞ ÏóêÎü¨ ÌôïÏù∏
        if result.returncode != 0:
            print(f"‚ùå Ïã§Ìñâ ÌååÏùº ÏóêÎü¨ (exit code: {result.returncode})")
            if result.stderr:
                print(f"ÏóêÎü¨ Ï∂úÎ†•:\n{result.stderr[:500]}")
            return False
        
        return True

    def show_results(self):
        """Show build results (ÌÅ¨Î°úÏä§ ÌîåÎû´Ìèº Ìò∏Ìôò)"""
        dist_dir = self.project_root / ("dist_windows" if self.system == "Windows" else "dist")
        if dist_dir.exists():
            print("\nüìÅ Generated files:")
            for item in dist_dir.iterdir():
                if item.is_file():
                    size_mb = item.stat().st_size / (1024 * 1024)
                    print(f"   - {item.name} ({size_mb:.1f}MB)")
                elif item.is_dir():
                    # ÎîîÎ†âÌÜ†Î¶¨ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (PythonÏúºÎ°ú Ï≤òÎ¶¨)
                    total_size = sum(f.stat().st_size for f in item.rglob('*') if f.is_file())
                    size_mb = total_size / (1024 * 1024)
                    print(f"   - {item.name}/ ({size_mb:.1f}MB)")

    def build_parallel_tasks(self, parallel_jobs=None):
        """Î≥ëÎ†¨Î°ú Ïã§ÌñâÌï† Ïàò ÏûàÎäî ÏûëÏóÖÎì§ÏùÑ ÎèôÏãúÏóê Ï≤òÎ¶¨"""
        if parallel_jobs is None:
            parallel_jobs = min(multiprocessing.cpu_count(), 3)

        print(f"üîÑ Î≥ëÎ†¨ ÏûëÏóÖ ÏãúÏûë ({parallel_jobs} workers)...")

        with ThreadPoolExecutor(max_workers=parallel_jobs) as executor:
            # Î≥ëÎ†¨Î°ú Ïã§ÌñâÌï† ÏûëÏóÖÎì§
            futures = {
                executor.submit(self.clean_build): "clean_build",
                executor.submit(self.create_sample_configs): "create_configs",
                executor.submit(self.update_spec_file): "update_spec",
            }

            # ÏûëÏóÖ ÏôÑÎ£å ÎåÄÍ∏∞
            for future in as_completed(futures):
                task_name = futures[future]
                try:
                    future.result()
                    print(f"‚úÖ {task_name} completed")
                except Exception as e:
                    print(f"‚ùå {task_name} failed: {e}")
                    raise

    def build(self, parallel_jobs=None):
        """Main build process with parallel optimization"""
        print(f"üöÄ Building ChatAI Agent for {self.system}")
        print("=" * 50)

        try:
            # 0. ÏùòÏ°¥ÏÑ± ÏûêÎèô ÌôïÏù∏ Î∞è ÏàòÏ†ï
            print("\nüîß Step 0: ÏùòÏ°¥ÏÑ± ÏûêÎèô ÌôïÏù∏ Î∞è ÏàòÏ†ï...")
            if not self.verify_and_fix_dependencies():
                raise Exception("ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Ïã§Ìå®")

            # 1. Backup configs (ÏàúÏ∞® Ïã§Ìñâ ÌïÑÏöî)
            print("\nüì¶ Step 1: Backing up config files...")
            self.backup_configs()

            # 2-3. Î≥ëÎ†¨ Ïã§Ìñâ Í∞ÄÎä•Ìïú ÏûëÏóÖÎì§ (spec ÌååÏùº ÏóÖÎç∞Ïù¥Ìä∏ Ï†úÏô∏)
            print("\nüîÑ Step 2: Î≥ëÎ†¨ ÏûëÏóÖ ÏãúÏûë...")
            if parallel_jobs is None:
                parallel_jobs = min(multiprocessing.cpu_count(), 3)
            
            with ThreadPoolExecutor(max_workers=parallel_jobs) as executor:
                futures = {
                    executor.submit(self.clean_build): "clean_build",
                    executor.submit(self.create_sample_configs): "create_configs",
                }
                for future in as_completed(futures):
                    task_name = futures[future]
                    try:
                        future.result()
                        print(f"‚úÖ {task_name} completed")
                    except Exception as e:
                        print(f"‚ùå {task_name} failed: {e}")
                        raise

            # 4. Build executable (Î≥ëÎ†¨ Ï≤òÎ¶¨ Ï†ÅÏö©)
            print("\nüî® Step 3: Building executable with parallel processing...")
            if not self.build_executable(parallel_jobs):
                raise Exception("Build failed")

            # 5. Verify build
            print("\nüîç Step 4: Verifying build...")
            if not self.verify_build():
                raise Exception("Build verification failed")

            # 6. Create distribution packages
            print("\nüì¶ Step 5: Creating distribution packages...")
            self.create_distribution_package()

            print("\n" + "=" * 50)
            print("‚úÖ Build completed successfully!")
            print("=" * 50)

            # 7. Show results
            self.show_results()
            
            # 8. Ïã§Ìñâ ÌÖåÏä§Ìä∏
            print("\nüß™ Step 6: Ïã§Ìñâ ÌÖåÏä§Ìä∏...")
            self.test_executable()

        except Exception as e:
            print(f"\n‚ùå Build failed: {e}")
            import traceback
            traceback.print_exc()
            return False

        finally:
            # Always restore configs - Îß§Ïö∞ Ï§ëÏöî!
            print("\nüîÑ ÏõêÎ≥∏ ÏÑ§Ï†ï ÌååÏùº Î≥µÍµ¨ Ï§ë... (ÌÖåÏä§Ìä∏ Í≥ÑÏÜçÏùÑ ÏúÑÌï¥ ÌïÑÏàò)")
            self.restore_configs()

        return True


def main():
    """Entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="ChatAI Agent ÎπåÎìú ÎèÑÍµ¨")
    parser.add_argument(
        "--parallel",
        "-p",
        type=int,
        default=None,
        help="Î≥ëÎ†¨ ÏûëÏóÖ Ïàò (Í∏∞Î≥∏Í∞í: CPU ÏΩîÏñ¥ Ïàò Í∏∞Î∞ò ÏûêÎèô ÏµúÏ†ÅÌôî)",
    )

    args = parser.parse_args()

    builder = PackageBuilder()
    builder.build(parallel_jobs=args.parallel)


if __name__ == "__main__":
    main()
