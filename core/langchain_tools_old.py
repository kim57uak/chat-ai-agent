from typing import Dict, Any, List, Optional, Type, Union
from langchain.tools import BaseTool
from langchain.callbacks.manager import CallbackManagerForToolRun
from pydantic import BaseModel, Field
from core.mcp import call_mcp_tool
import json
import logging
import inspect

logger = logging.getLogger(__name__)

class MCPToolInput(BaseModel):
    """MCP ÎèÑÍµ¨ ÏûÖÎ†• Ïä§ÌÇ§Îßà"""
    pass

class MCPTool(BaseTool):
    """MCP ÏÑúÎ≤ÑÏùò ÎèÑÍµ¨Î•º LangChain ToolÎ°ú ÎûòÌïë"""
    
    server_name: str = Field(description="MCP ÏÑúÎ≤Ñ Ïù¥Î¶Ñ")
    tool_name: str = Field(description="MCP ÎèÑÍµ¨ Ïù¥Î¶Ñ")
    tool_schema: Dict[str, Any] = Field(description="MCP ÎèÑÍµ¨ Ïä§ÌÇ§Îßà")
    
    def __init__(self, server_name: str, tool_name: str, tool_schema: Dict[str, Any], **kwargs):
        # ÎèôÏ†ÅÏúºÎ°ú ÏûÖÎ†• Ïä§ÌÇ§Îßà ÏÉùÏÑ±
        input_schema = self._create_input_schema(tool_schema)
        
        # ÎèÑÍµ¨ Ïù¥Î¶Ñ Í∏∏Ïù¥ Ï†úÌïú (OpenAI API 64Ïûê Ï†úÌïú)
        full_name = f"{server_name}_{tool_name}"
        if len(full_name) > 60:  # ÏïàÏ†Ñ ÎßàÏßÑ
            # ÏÑúÎ≤ÑÎ™Ö Ï∂ïÏïΩ
            server_short = server_name[:10] if len(server_name) > 10 else server_name
            tool_short = tool_name[:45] if len(tool_name) > 45 else tool_name
            full_name = f"{server_short}_{tool_short}"
        
        super().__init__(
            name=full_name,
            description=tool_schema.get("description", f"{server_name}Ïùò {tool_name} ÎèÑÍµ¨"),
            args_schema=input_schema,
            server_name=server_name,
            tool_name=tool_name,
            tool_schema=tool_schema,
            **kwargs
        )
    
    def _create_input_schema(self, tool_schema: Dict[str, Any]) -> Type[BaseModel]:
        """MCP ÎèÑÍµ¨ Ïä§ÌÇ§ÎßàÏóêÏÑú Pydantic Î™®Îç∏ ÏÉùÏÑ±"""
        input_schema = tool_schema.get("inputSchema", {})
        properties = input_schema.get("properties", {})
        required = input_schema.get("required", [])
        
        if not properties:
            return MCPToolInput
        
        # ÎèôÏ†ÅÏúºÎ°ú ÌïÑÎìú ÏÉùÏÑ±
        fields = {}
        annotations = {}
        
        for prop_name, prop_info in properties.items():
            prop_type = prop_info.get("type", "string")
            description = prop_info.get("description", "")
            
            # Python ÌÉÄÏûÖ Îß§Ìïë
            python_type = self._get_python_type(prop_type)
            
            # ÌïÑÏàò ÌïÑÎìú Ïó¨Î∂Ä ÌôïÏù∏
            if prop_name in required:
                annotations[prop_name] = python_type
                fields[prop_name] = Field(description=description)
            else:
                annotations[prop_name] = Optional[python_type]
                fields[prop_name] = Field(default=None, description=description)
        
        # ÎèôÏ†Å ÌÅ¥ÎûòÏä§ ÏÉùÏÑ±
        if fields:
            tool_name = tool_schema.get("name", "Unknown")
            safe_name = tool_name.replace("-", "_").replace(".", "_")
            DynamicInputSchema = type(
                f"{safe_name}Input",
                (BaseModel,),
                {
                    "__annotations__": annotations,
                    **fields
                }
            )
            return DynamicInputSchema
        
        return MCPToolInput
    
    def _get_python_type(self, json_type: str):
        """JSON Ïä§ÌÇ§Îßà ÌÉÄÏûÖÏùÑ Python ÌÉÄÏûÖÏúºÎ°ú Î≥ÄÌôò"""
        type_mapping = {
            "string": str,
            "number": float,
            "integer": int,
            "boolean": bool,
            "array": list,
            "object": dict
        }
        return type_mapping.get(json_type, str)
    
    def _run(self, *args, **kwargs: Any) -> str:
        """ÎèÑÍµ¨ Ïã§Ìñâ - LangChain Î≤ÑÏ†Ñ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ïú†Ïó∞Ìïú Ïù∏Ïàò Ï≤òÎ¶¨"""
        try:
            # run_manager Ï∂îÏ∂ú (ÏúÑÏπò Ïù∏Ïàò ÎòêÎäî ÌÇ§ÏõåÎìú Ïù∏Ïàò)
            run_manager = None
            if args and len(args) > 0:
                # Ï≤´ Î≤àÏß∏ Ïù∏ÏàòÍ∞Ä CallbackManagerForToolRun Ïù∏Ïä§ÌÑ¥Ïä§Ïù∏ÏßÄ ÌôïÏù∏
                if hasattr(args[0], 'on_text'):
                    run_manager = args[0]
            elif 'run_manager' in kwargs:
                run_manager = kwargs.pop('run_manager')
            
            # ÎèÑÍµ¨ Ïã§ÌñâÏóê ÌïÑÏöîÌïú ÌååÎùºÎØ∏ÌÑ∞Îßå Ï∂îÏ∂ú
            clean_kwargs = {k: v for k, v in kwargs.items() 
                          if v is not None and v != "" and v != {}}
            
            logger.info(f"MCP ÎèÑÍµ¨ Ìò∏Ï∂ú: {self.server_name}.{self.tool_name} with {clean_kwargs}")
            
            # run_managerÎ•º ÏÇ¨Ïö©Ìïú Î°úÍπÖ
            if run_manager and hasattr(run_manager, 'on_text'):
                try:
                    run_manager.on_text(f"MCP ÎèÑÍµ¨ Ìò∏Ï∂ú: {self.server_name}.{self.tool_name}")
                except:
                    pass  # Î°úÍπÖ Ïã§Ìå®Îäî Î¨¥Ïãú
            
            # MCP ÎèÑÍµ¨Ïóê Ï†ÑÎã¨Ìï† arguments Ï§ÄÎπÑ
            # Îπà Í∞íÎì§ÏùÑ Ï†úÍ±∞ÌïòÍ≥†, ÌïÑÏàò ÌïÑÎìúÍ∞Ä Îπ†ÏßÑ Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            arguments = {}
            
            # ÎèÑÍµ¨ Ïä§ÌÇ§ÎßàÏóêÏÑú ÌïÑÏàò ÌïÑÎìú ÌôïÏù∏
            input_schema = self.tool_schema.get('inputSchema', {})
            required_fields = input_schema.get('required', [])
            properties = input_schema.get('properties', {})
            
            # Ï†ÑÎã¨Îêú ÌååÎùºÎØ∏ÌÑ∞ Ï≤òÎ¶¨
            for key, value in clean_kwargs.items():
                if key in properties:
                    arguments[key] = value
            
            # ÌïÑÏàò ÌïÑÎìúÍ∞Ä Îπ†ÏßÑ Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            for field in required_fields:
                if field not in arguments:
                    # Í∏∞Î≥∏Í∞íÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
                    field_info = properties.get(field, {})
                    if 'default' in field_info:
                        arguments[field] = field_info['default']
                    else:
                        logger.warning(f"ÌïÑÏàò ÌïÑÎìú '{field}'Í∞Ä Îπ†Ï°åÏäµÎãàÎã§: {clean_kwargs}")
            
            logger.info(f"MCP ÎèÑÍµ¨Ïóê Ï†ÑÎã¨Ìï† arguments: {arguments}")
            
            result = call_mcp_tool(self.server_name, self.tool_name, arguments if arguments else None)
            
            if result is None:
                return f"ÎèÑÍµ¨ '{self.tool_name}' Ìò∏Ï∂ú Ïã§Ìå®"
            
            # Í≤∞Í≥ºÎ•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
            if isinstance(result, dict):
                return json.dumps(result, ensure_ascii=False, indent=2)
            elif isinstance(result, list):
                return json.dumps(result, ensure_ascii=False, indent=2)
            else:
                return str(result)
                
        except Exception as e:
            logger.error(f"MCP ÎèÑÍµ¨ Ïã§Ìñâ Ïò§Î•ò: {e}")
            if run_manager and hasattr(run_manager, 'on_text'):
                try:
                    run_manager.on_text(f"Ïò§Î•ò: {str(e)}")
                except:
                    pass
            return f"ÎèÑÍµ¨ Ïã§Ìñâ Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(e)}"


class MCPToolRegistry:
    """MCP ÎèÑÍµ¨Î•º LangChain ÎèÑÍµ¨Î°ú Îì±Î°ù Î∞è Í¥ÄÎ¶¨"""
    
    def __init__(self):
        self.tools: List[MCPTool] = []
        self.tools_by_category: Dict[str, List[MCPTool]] = {}
    
    def register_mcp_tools(self, all_mcp_tools: Dict[str, List[Dict[str, Any]]]) -> List[MCPTool]:
        """MCP ÎèÑÍµ¨Îì§ÏùÑ LangChain ÎèÑÍµ¨Î°ú Îì±Î°ù"""
        self.tools.clear()
        self.tools_by_category.clear()
        
        for server_name, tools in all_mcp_tools.items():
            server_tools = []
            
            for tool_schema in tools:
                tool_name = tool_schema.get("name")
                if not tool_name:
                    continue
                    
                try:
                    mcp_tool = MCPTool(
                        server_name=server_name,
                        tool_name=tool_name,
                        tool_schema=tool_schema
                    )
                    
                    self.tools.append(mcp_tool)
                    server_tools.append(mcp_tool)
                    logger.info(f"ÎèÑÍµ¨ Îì±Î°ù ÏÑ±Í≥µ: {server_name}.{tool_name}")
                    
                except Exception as e:
                    logger.error(f"ÎèÑÍµ¨ Îì±Î°ù Ïã§Ìå® {server_name}.{tool_name}: {e}")
                    logger.error(f"ÎèÑÍµ¨ Ïä§ÌÇ§Îßà: {tool_schema}")
                    import traceback
                    logger.error(f"ÏÉÅÏÑ∏ Ïò§Î•ò: {traceback.format_exc()}")
                    continue
            
            if server_tools:
                self.tools_by_category[server_name] = server_tools
        
        logger.info(f"Ï¥ù {len(self.tools)}Í∞ú ÎèÑÍµ¨ Îì±Î°ù ÏôÑÎ£å")
        
        # Îì±Î°ùÎêú ÎèÑÍµ¨ Î™©Î°ù Ï∂úÎ†•
        for tool in self.tools:
            logger.info(f"  ‚úì {tool.name}")
        
        return self.tools
    
    def get_tools(self, category: Optional[str] = None) -> List[MCPTool]:
        """ÎèÑÍµ¨ Î™©Î°ù Î∞òÌôò"""
        if category:
            return self.tools_by_category.get(category, [])
        return self.tools
    
    def get_tool_by_name(self, name: str) -> Optional[MCPTool]:
        """Ïù¥Î¶ÑÏúºÎ°ú ÎèÑÍµ¨ Ï∞æÍ∏∞"""
        for tool in self.tools:
            if tool.name == name:
                return tool
        return None
    
    def get_tools_description(self) -> str:
        """ÎèÑÍµ¨ Î™©Î°ù ÏÑ§Î™Ö Î∞òÌôò"""
        if not self.tools:
            return "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎèÑÍµ¨Í∞Ä ÏóÜÏäµÎãàÎã§."
        
        descriptions = []
        for category, tools in self.tools_by_category.items():
            descriptions.append(f"\nüì¶ {category} ({len(tools)}Í∞ú ÎèÑÍµ¨):")
            for tool in tools[:5]:  # Ï≤òÏùå 5Í∞úÎßå
                descriptions.append(f"  üîß {tool.name}: {tool.description[:100]}...")
            if len(tools) > 5:
                descriptions.append(f"  ... Î∞è {len(tools) - 5}Í∞ú Îçî")
        
        return "\n".join(descriptions)


# Ï†ÑÏó≠ ÎèÑÍµ¨ Î†àÏßÄÏä§Ìä∏Î¶¨
tool_registry = MCPToolRegistry()